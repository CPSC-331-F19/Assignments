\documentclass[12pt]{article}
 
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb,scrextend}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{fancyvrb}
\pagestyle{fancy}
 
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\lbr}{\lbrace}
\newcommand{\rbr}{\rbrace}
\renewcommand{\qed}{\hfill$\blacksquare$}
\let\newproof\proof
% \renewenvironment{proof}{\begin{addmargin}[1em]{0em}\begin{newproof}}{\end{newproof}\end{addmargin}\qed}
 
\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{reflection}[2][Reflection]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{proposition}[2][Proposition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
 
\begin{document}
 
% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------

\title{Assignment 1 \\ CPSC 331} % Title and subtitle
\author{Guransh Mangat, 30061719 \\ Daniel Contreras, 10080311 \\ Steven Ferguson, 30037518\\}
\date{}


\lhead{CPSC 331}
\chead{Assignment 1}
\rhead{September 2019}
 
\maketitle{}

\newpage

% --------------------------------------------------------------
%                         1
% --------------------------------------------------------------

\begin{problem}{1}
    Suppose that the function $f(n)=n$ is a bound function.
\end{problem}

\begin{proof}
    Since $n$ is an integer input, this is an \textit{integer-valued} function.\\ \\ When the 
    recursive function is applied in \textit{line 9}, the value of n is reduced by at least 1 
    ($(n-1), (n-3) \ and \ (n-4)$). \newline \newline $n$ is a non negative integer, which means 
    $n \geq 0$. Thus it is only possible that $ f(n) = n \leq 0$ when n = 0. In that case, the test 
    at \textit{line 1} passes, the execution continues at \textit{line 1} and the execution ends 
    without having to call the recursive function repeatedly. \newline \newline Hence, the function 
    $f(n) = n$ is a bound function. 
\end{proof}

% --------------------------------------------------------------
%                         2
% --------------------------------------------------------------

\begin{problem}{2}
    Prove that the smacG algorithm correctly solves the ``MacGonagall Mystery Computation" problem.
\end{problem}

\begin{proof}
    \noindent This theorem will be proved by induction on $n$. The strong form of mathematical induction will be used, and base cases of $n = 0, 1, 2 ,3$ will each be considered in the basis.\\
    
    \noindent Basis: Suppose, first $n = 0$: \newline During the execution of algorithm smacG on input $n$, the test at line 1 succeeds and the execution continues at line 2. This causes the execution to terminate with the value of $M_0 = 1$ returned at output - as required for this case \\ 
    
    \noindent Suppose, next, $n = 1$: \\ During the execution of the algorithm smacG, the test at line 1 fails and the execution continues with test at line 3. \\ This test succeeds, so the execution continues at line 4. This causes the execution of algorithm to terminate with value of $M_1 = 0$ returned as output- as required by this case \\ 
    
    \noindent Suppose, $n = 2$: \\ During the execution of the algorithm smacG, the test at line 1 and line 3 fails, and the execution continues with test at line 5. \\ This test succeeds, so the execution continues with line 6. This causes the execution of the algorithm to terminate with the value of $M_2 = 5$ returned as output - as require by this case. \\ 
    
    \noindent Suppose, n = 3: \\ During the execution of the algorithm smacG, the test at line 1, line 3 and line 5 fails, and the execution continues with the test at line 7. \\ This test succeeds, so the execution continues with line 8. This causes the execution of the algorithm to terminate with the value of $M_3 = 8$ returned as output - as required by this case. \\ 
    
    \noindent \textit{Inductive Step: } Let $k$ be an integer such that $k \geq 3$. \\
    
    \noindent \textbf{Inductive Hypothesis: } Suppose $n$ is a non-negative integer such that $ 0 \leq n \leq k$. If the algorithm smacG is executed given n as input then this execution of the algorithm eventually terminates, with the $n^{th}$ MacGonagall number, $M_n$ returned as output. \\
    
    \noindent \textbf{Inductive Claim: } If the algorithm smacG is executed given $n = k + 1$ as input then this execution of the algorithm eventually terminates, with the $k+1^{st}$ MacGonagall number $M_{k+1} = M_n$ returned as output. \\
    
    \noindent Suppose the algorithm smacG is executed with $n= k + 1$ given as input. Since $k$ is an integer such that $k \geq 3$, $n$ is an integer such that $n \geq 4$.
    
    \noindent Since $n \geq 4$, the test at line 1, line 3, line 5 and line 7 fails and the algorithm continues at line 8. 
    
    \noindent Line 9 includes a recursive execution of this algorithm with the input $2 \times (n-1)$. Since $n = k + 1 \geq 4, 0 \leq n-1 = k \leq k$, and it follows by the \textbf{inductive hypothesis} that this recursive execution of the algorithm eventually ends with $M_{n-1} = M_k$ returned as output
    
    \noindent Line 9 also includes a recursive execution of this algorithm with the input $-2 \times (n-3)$. Since $n = k+1 \geq 4, 0 \leq n-3 = k-2 \leq k$, and it follows the \textbf{inductive hypothesis} that this recursive execution of the algorithm eventually ends with $M_{n-3} = M_{k-2}$ returned as output.
    
    \noindent Line 9 also includes a recursive execution of algorithm with the input $n-4$. Since $n = k+1 \geq 4, 0 \leq n-4 = k-3 \leq 4$, and it follows by the \textbf{inductive hypothesis} that this recursive function of the algorithm eventually ends with $M_{n-4} = M_{k-3}$ returned as output.
    
    \noindent Once the execution of algorithm ends, since, $k+1 \geq 4$, it follows the definition of $M_{k+1}$, that the value returned as output is: \\ \\
    $2 \times M_{n-1} - 2 \times M_{n-3} + M_{n-4} = 2 \times M_{k} -2 \times M_{k-2} + M_{k-3} = M_{k+1}$ \\ 
    
    \noindent as required to establish the \textbf{inductive claim.} \\ \\
    This results now follows by induction on n.
\end{proof}


% --------------------------------------------------------------
%                         3
% --------------------------------------------------------------

\begin{problem}{3} $\:$
\begin{Verbatim}[fontsize=\small]
package cpsc331.assignment1;
/**
 *
 * A class for the recursive computation of the MacGonagall Mystery sequence
 *
 * @author Steven Ferguson (30037518)
 * @author Daniel Contreras (10080311)
 * @author Guransh Mangat (30061719)
 * @version 1.0
 *
 */

public class SMacGonagall {

    /**
     *
     * The main method for this class.
     *
     * @param args A single non-negative integer n.
     *
     */

    public static void main(String[] args) {

        if (args.length != 1) {
            System.out.println("Fiddlesticks! One integer input is required.");
            return;
        }

        try {
            int n = Integer.parseInt(args[0]);
            System.out.println(smacG(n));
        } catch (NumberFormatException e) {
            System.out.println("Fiddlesticks! One integer input is required.");
        } catch (IllegalArgumentException e) {
            System.out.println("Fiddlesticks! The integer input cannot be negative.");
        }

    }

    /**
     *
     *  Computes the nth MacGonagall Number M_n, throwing
     *  an IllegalArgumentException if n is negative.
     *
     * Precondition:
     * An integer n given as input.
     *
     * Postcondition:
     * The nth MacGonagall Number, M_n is returned as output, and
     * an IllegalArgumentException is thrown if n < 0.
     *
     * @param n the MacGonagall Number to be computed
     * @return the nth MacGonagall Number, M_n
     * @throws IllegalArgumentException if the input is negative
     *
     */

    public static int smacG(int n) throws IllegalArgumentException {

        // Assertion: n is an integer such that n >= 0

        if(n < 0) {
            throw new IllegalArgumentException();
        }

        switch (n) {
            case 0:
                return 1;
            case 1:
                return 0;
            case 2:
                return 5;
            case 3:
                return 8;
            default:
                return 2 * smacG(n - 1) - 2 * smacG(n - 3) + smacG(n - 4);
        }

        // Assertion:
        // 1. n is an integer such that n >= 0
        // 2. The nth MacGonagall number, M_n is returned as output


    }
}
\end{Verbatim}
\end{problem}




% --------------------------------------------------------------
%                         4
% --------------------------------------------------------------

\begin{problem}{4}
Let $T_{smacG}(n)$ be the number of steps included in the execution of the algorithm, $smacG$,
shown in Figure 1 on input n, for a non-negative integer n — assuming that the uniform
cost criterion is used to define this and the only steps counted are the numbered steps
shown in Figure 1.
\\
Give a recurrence for $T_{smacG}(n)$.
\end{problem}

\begin{proof}
    In order to determine the number of steps included in the execution of $T_{smacG}(n)$, we will define the running time of each step in the algorithm to be \textit{one}.\\

    \noindent Using the uniform cost criterion to define $T_{smacG}(n)$: \\
    
    \noindent The algorithm executes 2 steps (at lines 1 and 2) if it is executed when $n = 0$. \\
    \noindent The algorithm executes 3 steps (at lines 1, 3, 4) if it is executed when $n = 1$. \\
    \noindent The algorithm executes 4 steps (at lines 1, 3, 5, 6) if it is executed when $n = 2$. \\
    \noindent The algorithm executes 5 steps (at lines 1, 3, 5, 7, 8) if it is executed when $n = 3$. \\
    
    
    \[ \hspace*{-17mm}T_{smacG}(n) = 
        \begin{cases} 
          2 & if n = 0, \\
          3 & if n = 1, \\
          4 & if n = 2, \\
          5 & if n = 3, \\
          T_{smacG}(n-1) + T_{smacG}(n-3) + T_{smacG}(n-4) + 5 & if n \geq 4.
       \end{cases}
    \]
    
    \noindent We can use this recurrence to show the following:\\
    
    \begin{flalign*}
        \hspace*{5mm}T_{smacG}(0) &= 2 &&\text{(by definition of $T_{smacG}(n)$)} \\ \\
        \hspace*{5mm}T_{smacG}(1) &= 3 &&\text{(by definition of $T_{smacG}(n)$)} \\ \\
        \hspace*{5mm}T_{smacG}(2) &= 4 &&\text{(by definition of $T_{smacG}(n)$)} \\ \\
        \hspace*{5mm}T_{smacG}(3) &= 5 &&\text{(by definition of $T_{smacG}(n)$)} \\ \\
        \hspace*{5mm}T_{smacG}(4) &= T_{smacG}(4-1) + T_{smacG}(4-3) + T_{smacG}(4-4) + 5  &&\text{} \\
        &= T_{smacG}(3) + T_{smacG}(1) + T_{smacG}(0) + 5  &&\text{} \\
        &= 5 + 3 + 2 + 5  &&\text{} \\
        &= 15. \\ \\
        \hspace*{5mm}T_{smacG}(5) &= T_{smacG}(5-1) + T_{smacG}(5-3) + T_{smacG}(5-4) + 5 &&\text{} \\
        &= T_{smacG}(4) + T_{smacG}(2) + T_{smacG}(1) + 5 &&\text{} \\
        &= 15 + 4 + 3 + 5 &&\text{} \\
        &= 27.
    \end{flalign*}

\end{proof}


% --------------------------------------------------------------
%                         5
% --------------------------------------------------------------

\begin{problem}{5} 
    Suppose that $T_{smacG}$ is a function of the non-negative integers such that, for every integer 
    $n \geq 0$,

    \[  
        \hspace*{-22mm}T_{smacG}(n) =
        \begin{cases} 
        2 & n = 0 \\
        3 & n = 1 \\
        4 & n = 2 \\
        5 & n = 3 \\
        T_{smacG}(n-1) + T_{smacG}(n-3) + T_{smacG}(n-4) + 5 & n \geq 4 
        \end{cases}
    \]

    \noindent then $T_{smacG}(n) \geq \left(\frac{3}{2}\right)^n$ for every non-negative integer $n$ and therefore
    the number of steps executed by the $smacG$ algorithm is at least exponential in its input.
\end{problem}

\begin{proof} 
This will be established by induction on $n$. The strong form of mathematical induction will be used 
and the cases $n = 0$, $n=1$, $n=2$ and $n=3$ will be considered in the basis.\\

\noindent \textit{Basis}. If $n=0$, then $T_{smacG}\left(n\right) = T_{smacG}\left(0\right) = 2$, and 
\begin{flalign*}
    \hspace*{5mm}T_{smacG}(n) &\geq \left(\frac{3}{2}\right)^n &&\text{} \\
    T_{smacG}\left(0\right) &\geq \left(\frac{3}{2}\right)^0 &&\text{} \\
    2 &\geq 1 &&\text{} \\
\end{flalign*}
as required. If $n=1$, then $T_{smacG}\left(n\right) = T_{smacG}\left(1\right) = 3$, and 
\begin{flalign*}
    \hspace*{5mm}T_{smacG}\left(n\right) &\geq \left(\frac{3}{2}\right)^n &&\text{} \\
    T_{smacG}\left(1\right) &\geq \left(\frac{3}{2}\right)^1 &&\text{} \\
    3 &\geq \frac{3}{2} &&\text{} \\
\end{flalign*}
as required. If $n=2$, then $T_{smacG}\left(n\right) = T_{smacG}\left(2\right) = 4$, and 
\begin{flalign*}
    \hspace*{5mm}T_{smacG}\left(n\right) &\geq \left(\frac{3}{2}\right)^n &&\text{} \\
    T_{smacG}\left(2\right) &\geq \left(\frac{3}{2}\right)^2 &&\text{} \\
    4 &\geq \frac{9}{4} &&\text{} \\
\end{flalign*}
as required. If $n=3$, then $T_{smacG}\left(n\right) = T_{smacG}\left(3\right) = 5$, and 
\begin{flalign*}
    \hspace*{5mm}T_{smacG}\left(n\right) &\geq \left(\frac{3}{2}\right)^n &&\text{} \\
    T_{smacG}\left(3\right) &\geq \left(\frac{3}{2}\right)^3 &&\text{} \\
    5 &\geq \frac{27}{8} &&\text{} \\
\end{flalign*}
as required. \\

\noindent \textit{Inductive Step}. Let $k \geq 4$ be an integer. It is necessary and sufficient
to use the following \\

\underline{Inductive Hypothesis}: $T_{smacG}\left(m\right) \geq \left(\frac{3}{2}\right)^{m}$
for every integer $m$ such that $0 \leq m \leq k$. \\

\noindent to prove the following \\

\underline{Inductive Claim}: $T_{smacG}\left(k+1\right) \geq \left(\frac{3}{2}\right)^{k+1}$ \\

\noindent Now, since $k+1 > 4$,

\begin{flalign*}
    \hspace*{5mm}T_{smacG}(k+1) &= T_{smacG}(k) + T_{smacG}(k-2) + T_{smacG}(k-3) + 5 \\
    &\geq \left(\frac{3}{2}\right)^{k} + \left(\frac{3}{2}\right)^{k-2} + \left(\frac{3}{2}\right)^{k-3} + 5 &&\text{(by inductive hypothesis)} \\
    &= \left(\frac{3}{2}\right)^{k+1} + \left(\left(\frac{3}{2}\right)^{-1} + \left(\frac{3}{2}\right)^{-3} + \left(\frac{3}{2}\right)^{-4}\right) + 5 \\
    &= \left(\frac{3}{2}\right)^{k+1} \left(\frac{94}{81}\right) + 5 \\
    &\geq \left(\frac{3}{2}\right)^{k+1} \left(\frac{94}{81}\right) \\
    &\geq \left(\frac{3}{2}\right)^{k+1} &&\text{(because $\frac{94}{81} > 1$)}\\
\end{flalign*}

\noindent thus establishing the inductive claim, as needed. Therefore, by principle of induction 
$T_{smacG}\left(n\right) \geq \left(\frac{3}{2}\right)^{n}$ for all non-negative integers $n$.

\end{proof} 

% --------------------------------------------------------------
%                         6
% --------------------------------------------------------------

\begin{problem}{6}
State a loop invariant for the while loop at lines $15 \-- 17$
of this algorithm
\end{problem}

\begin{proof}
\begin{enumerate}
        \item \textit{n} is an integer input such that $n \geq 4$
        \item \textit{i} is an integer variable such that $4 \leq i \leq n$
        \item \textit{M} is an integer array with length $n+1$
        \item $M_{j} = fmacG_{j}$ for every integer j such that $ 0 \leq j \leq i$
   \end{enumerate}
\end{proof}


% --------------------------------------------------------------
%                         7
% --------------------------------------------------------------

\begin{problem}{7}
Prove that your answer for the previous question really is a loop invariant for the while
loop in this algorithm.
\end{problem}

\begin{proof}
We will use Loop Theorem 1 to prove this loop invariant.
\begin{enumerate}
    \item The loop test at \textit{line 15} has no side effects. 
    \item Consider the execution of the algorithm with the precondition for the ``MacGonagall Mystery Computation" satisfied. There is nothing to be proved if the while loop at \textit{line 15} is never reached, so if tests at \textit{line 1, 3, 5, 7} fail, then \textit{lines 9-15} are executed. By the inspection of code, we can say that the loop is not executed more than once. So it suffices us to consider the first execution of the loop. 
    \\
    The precondition for the ``MacGonagall Mystery Computation" states that $n$ needs to be a non-negative integer i.e. $n \geq 0$ when the execution of the algorithm begins and by inspection, the value of $n$ never changes. Furthermore, $n \neq 1,2,3$ as tests at \textit{line 1, 3, 5 and 7} pass and the loop is never reached. Thus, $n \geq 4$ which establishes part 1 of the loop invariant when the execution of loop begins. One can see by the inspection of the code, $i$ is an integer variable with a value of $4$ when the execution of the loop begins, since $n \geq 4$, this establishes part 2 of the loop invariant when the execution of the loop begins. Since $M$ is an \textit{integer-array} variable whose length is set to be $n+1$. Finally, since \emph{lines 10, 11, 12, and 13} have been executed (and M is not changed at step 14), $M[0] = fmacG_{0}, M[1] = fmacG_{1}, M[2] = fmacG_{2}, and M[3] = fmacG_{3}$. Since $i=4, M[j] = fmacG_{j}$ for every integer $j$ such that $0 \leq i \leq j$. Thus, the fourth part of the assertion before the execution of the loop body, as required for the proof of the claim.
    
    \item Consider an execution of the body of this loop that begins with the proposed "loop invariant" satisfied. It follows by \emph{part 1} of the loop invariant that $n$ is initially and integer variable such that $n \geq 4$ and since, the value of $n$ is not changed during the executions of \emph{line 16, 17}, this is also true when the execution of this loop ends. It follows by \emph{part 2} of the loop invariant that $i$ is an integer variable such that $4 \leq i \leq n$. Since, the test at \emph{line 15} was checked and passed, $i < n$ so that $4 \leq i \leq n-1$ at this point.
    When the value of n is never changed, the value of $i$ is increased by one during the execution of \emph{line 17}, so $5 \leq i \leq n$ at the end of the execution of this loop body and \emph{part 2} of the loop invariant is satisfied at the end of this execution of the loop body as well.
    
   \end{enumerate}
\end{proof}


% --------------------------------------------------------------
%                         8
% --------------------------------------------------------------

\begin{problem}{8}
 Use this to prove that this algorithm is \textbf{partially correct}.(\textbf{References}: Lecture 3 and Tutorial Exercise 4)
\end{problem}


\begin{proof}


\noindent
When observing the function signature for $fmacG(n)$, this algorithm has no undocumented side effects, since it is not accessing or modifying inputs or global data, and does not create outputs unless stated otherwise in the ``MacGongall Mystery Computation" problem. \\

\noindent
It is now sufficient to prove that if the $fmacG(n)$ is executed when the precondition for the ``MacGongall Mystery Computation" is satisfied, then either:
\begin{enumerate}[label=(\alph*)]
\item The algorithm's execution terminates, with the post-condition for the ``MacGongall Mystery Computation" problem being satisfied, or alternatively
\item The algorithm runs forever, whereby the algorithm never terminates at all
\end{enumerate}

\noindent
Now, consider an execution of this algorithm where the precondition of this problem is initially satisfied. That is, $n$ is an integer input where $n \geq 0$.

\begin{itemize}

\item Suppose that $n = 0$. Then the test at line 1 passes, and the algorithm's execution halts after reaching line 2, where $M_0 = M_n = 1$ is returned as required to satisfy our condition established in $(a)$.

\item Suppose that $n = 1$. Then the test at line 1 fails, and the algorithm's execution proceeds and passes the test at line 3, where the algorithm's execution halts after reaching line 4, and $M_1 = M_n = 0$ is returned, as required to satisfy our condition established in $(a)$.

\item Suppose that $n = 2$. Then the test at line 1 and 3 fail, and the algorithm's execution proceeds and passes the test at line 5, where the algorithm's execution halts after reaching line 6, and $M_2 = M_n = 5$ is returned, as required to satisfy our condition established in $(a)$.

\item Suppose that $n = 3$. Then the test at line 1, 3, and 5 fail, and the algorithm's execution proceeds and passes the test at line 7, where the algorithm's execution halts after reaching line 8, and $M_3 = M_n = 8$ is returned, as required to satisfy our condition established in $(a)$.

\item The last and final case is when $n \geq 4$, such that the tests at lines 1, 3, 5, and 7 fail, and steps at $9 \rightarrow 14$ are executed, proceeding to the while loop-body that is later executed. Should the while loop run indefinitely, then the algorithm's execution never terminates, and the condition established in $(b)$ is satisfied. \\

If the algorithm does not halt during loop body execution, then the loop invariant is satisfied at this point of execution, such that $n$ is an input integer where $n \geq 4$, and $i$ is an integer variable such that $4 \leq i \leq n$ as established in $(1)$ and $(3)$ of the loop invariant. Since the algorithm terminates, and the test at line 15 has been evaluated and failed, this means $i \leq n$ as well, such that $i = n$ after the execution of the loop body.

\end{itemize}

\noindent
Thus, for part 4 of the loop invariant, $M[j] = fmacG_j = M_n$ such that the nth MacGonagall has been returned as output following the return statement at line 18 being executed, where condition $(a)$ has been satisfied.

\end{proof}

% --------------------------------------------------------------
%                         9
% --------------------------------------------------------------

\begin{problem}{9}
    The function $f\left(n,i\right) = n - (i - 1)$ is a bound function for the while
    loop in this algorithm. 
\end{problem}

\begin{proof} Consider the above function $f$. \\

    \noindent Since $n$ is an integer input and $i$ is an integer variable, defined and 
    initialized at step 14, this is certainly an integer-valued total function of
    some of the inputs, variables and global data in the $fmacG$ algorithm. \\

    \noindent When the body of the while loop is executed, the value of $i$ is increased
    by one (at step 17) and the value of $n$ is not changed. Hence, the value of $f$ is
    decreased by at least one. \\

    \noindent If the value of $f$ is less than zero then $n-(i-1) < 0$, so that $i > n$ and the loop
    test (at line 15) fails, causing the execution of the loop to halt. \\

    \noindent It then follows by definition of a bound function for a while loop that $f$ is a bound 
    function for the while loop in the $fmacG$ algorithm, as claimed.
\end{proof}


% --------------------------------------------------------------
%                         10
% --------------------------------------------------------------

\begin{problem}{10}
Suppose the $fmacG(n)$ algorithm is executed so that the precondition for the “MacGonagall Mystery Computation” problem is satisfied. The precondition of this problem assumes that is a non-negative integer before execution of the algorithm begins (i.e. $n \geq 0$.) \\

\noindent
When n = 0, the test at line 1 passes, and the algorithm's execution halts after reaching line 2. \\

\noindent
When n = 1, the test at line 1 fails, and the algorithm's execution passes the test at line 3, where its execution halts after the line 4. \\

\noindent
When n = 2, the test at line 1 and 3 fail, and the algorithm's execution proceeds and passes the test at line 5, where execution halts after reaching line 6. \\

\noindent
When n = 3, the test at line 1, 3, and 5 fail, and the algorithm's exeuction proceeds and passes the test at line 7, where execution halts after reaching line 8. \\

\noindent
Otherwise, if $n \geq 4$, the test at lines 1, 3, 5, and 7 fail, and the steps at lines $9 \rightarrow 14$ execute, whereby the loop-body is then executed.

\begin{itemize}
    \item At line 15, the loop-test compares integer input $n$ and a counter variable $i$, therefore it has no side effects, and the loop-body halts after each execution.
    \item Since the body of the while loop is simply two assignment operations, every execution of the loop body halts as well.
    \item As mentioned in question (9), this while loop has a bound function.
\end{itemize}

\noindent
It can now be proved using ``Loop Theorem \#2'' that the execution of the while loop halts. The execution of this algorithm halts after the execution of the return statement at line 18, which establishes the claim as required. It now follows in question $(11)$ that this algorithm is provably correct.

\noindent
\textbf{Reference: }Lecture 3 and Tutorial Exercise 4

\end{problem}


% --------------------------------------------------------------
%                         11
% --------------------------------------------------------------

\begin{problem}{11}
Using what has been proved so far, complete a proof that the fmacG algorithm correctly
solves the “MacGonagall Mystery Computation" problem.

\end{problem}

\begin{proof}
According to the notes from Lecture 3, Claim \#7 ``If an algorithm, for a given computational problem, is
both partially correct and terminates, whenever it is executed when its problem’s precondition initially satisfied, then this algorithm is correct".
\\ 
\\
The proof from \textbf{Problem 8} proves the partial correctness of the ``MacGongall Mystery Computation" problem and the proof from \textbf{Problem 10} proves the termination of the ``MacGongall Mystery Computation" problem.
\\
Since, the algorithm is both partially correct and terminates, whenever it is executed it's precondition satisfied, it will be correct. 

\end{proof}


% --------------------------------------------------------------
%                         12
% --------------------------------------------------------------

\begin{problem}{12}
    An upper bound function for $T_{fmacG}(n)$ in its closed form can be found by the following 
    methods. 
\end{problem}

\noindent Suppose, first that the algorithm is executed with input $n=0$. \\

\begin{itemize}
    \item In this case the test at line 1 is checked and passed. The execution continues and ends with the
    execution of the return statement at line 2. Thus, the number of steps in this case is 2. 
\end{itemize}


\noindent Next, suppose that the algorithm is executed with input $n=1$\\

\begin{itemize}
    \item In this case the test at line 1 is checked and fails, then the test at line 3 is checked 
    and passes and ends with the execution of the return statement at line 4. Thus, the number of
    steps in this case is 3.
\end{itemize}

\noindent Next, suppose that the algorithm is executed with input $n=2$\\

\begin{itemize}
    \item In this case the test at line 1 is checked and fails, then the test at line 3 is checked 
    and fails, then the test at line 5 is checked and passes and ends with the execution of the 
    return statement at line 6. Thus, the number of steps in this case is 4.
\end{itemize}

\noindent Next, suppose that the algorithm is executed with input $n=3$\\

\begin{itemize}
    \item In this case the test at line 3 is checked and fails, then the test at line 3 is checked 
    and fails, then the test at line 5 and also fails then the test at line 7 is checked and passes
    and ends with the execution of the return statement at line 8. Thus, the number of steps in 
    this case is 5.
\end{itemize}

\noindent Suppose instead that $n \geq 4$. 

\begin{itemize}
    \item In this case, the tests at lines 1, 3, 5 and 7 are checked and all fail, so the steps at 
    continue and execute lines 9-14 before the while loop. Hence, 10 steps are executed before
    the while loop begins.
    
    \item The initial value for the bound function for this loop is $n-3$, so there are at most $n-3$ 
    executions of the body of the while loop and at most $n-2$ executions of the loop test.
    
    \item The loop body consists of two statements, at lines 16-17. There are no loops, tests or method
    calls, so every execution of the loop body includes two steps: For $4 \leq j \leq n-3$, the cost
    of the $j^{th}$ execution of the loop body is
        \begin{flalign*}
            \hspace*{5mm}T_{body}(j) &= 2 && \text{}
        \end{flalign*}
    if there is actually a $j^{th}$ execution of the body of the loop.

    \item Similarly, the loop test consists of a single statement which does not call any other methods - 
    so, for $1 \leq j \leq n-2$
        \begin{flalign*}
            \hspace*{5mm}T_{test}(j) &= 1 && \text{}
        \end{flalign*}
    if there is actually a $j^{th}$ execution of the body of the loop.

    \item It now follows that the total number of steps included in this execution of the loop is at most,
        \begin{flalign*}
            \hspace*{5mm}\sum_{j=1}^{n-3} T_{body}(j) + \sum_{j=1}^{n-2} T_{test}(j) &= \sum_{j=1}^{n-3} 2 + \sum_{j=1}^{n-2} 1 &&\text{} \\
            &= 2(n-3)+(n-2) \\
            &= 2n-6+n-2 \\
            &= 3n-8 
        \end{flalign*}

    \item There is only one more statement executed after this, at line 18, and the cost of this is 1.
    
    \item Since $10 + (3n-8) + 1 = 3n+3$, it now follows that the number of steps included in an execution
    of this algorithm on a non-negative integer input $n$ is,
    \[  
        \hspace*{-91mm}T_{fmacG}(n) =
        \begin{cases} 
        2 & n = 0 \\
        3 & n = 1 \\
        4 & n = 2 \\
        5 & n = 3 \\
        3n+3 & n \geq 4 
        \end{cases}
    \]

        
\end{itemize}


\noindent Suppose, first that the algorithm is executed with input $n=0$. \\

\begin{itemize}
    \item In this case the test at line 1 is checked and passed. The execution continues and ends with the
    execution of the return statement at line 2. Thus, the number of steps in this case is 2. 
\end{itemize}


\noindent Next, suppose that the algorithm is executed with input $n=1$\\

\begin{itemize}
    \item In this case the test at line 1 is checked and fails, then the test at line 3 is checked 
    and passes and ends with the execution of the return statement at line 4. Thus, the number of
    steps in this case is 3.
\end{itemize}

\noindent Next, suppose that the algorithm is executed with input $n=2$\\

\begin{itemize}
    \item In this case the test at line 1 is checked and fails, then the test at line 3 is checked 
    and fails, then the test at line 5 is checked and passes and ends with the execution of the 
    return statement at line 6. Thus, the number of steps in this case is 4.
\end{itemize}

\noindent Next, suppose that the algorithm is executed with input $n=3$\\

\begin{itemize}
    \item In this case the test at line 3 is checked and fails, then the test at line 3 is checked 
    and fails, then the test at line 5 and also fails then the test at line 7 is checked and passes
    and ends with the execution of the return statement at line 8. Thus, the number of steps in 
    this case is 5.
\end{itemize}

\noindent Suppose instead that $n \geq 4$. 

\begin{itemize}
    \item In this case, the tests at lines 1, 3, 5 and 7 are checked and all fail, so the steps at 
    continue and execute lines 9-14 before the while loop. Hence, 10 steps are executed before
    the while loop begins.
    
    \item The initial value for the bound function for this loop is $n-3$, so there are at most $n-3$ 
    executions of the body of the while loop and at most $n-2$ executions of the loop test.
    
    \item The loop body consists of two statements, at lines 16-17. There are no loops, tests or method
    calls, so every execution of the loop body includes two steps: For $4 \leq j \leq n-3$, the cost
    of the $j^{th}$ execution of the loop body is
        \begin{flalign*}
            \hspace*{5mm}T_{body}(j) &= 2 && \text{}
        \end{flalign*}
    if there is actually a $j^{th}$ execution of the body of the loop.

    \item Similarly, the loop test consists of a single statement which does not call any other methods - 
    so, for $1 \leq j \leq n-2$
        \begin{flalign*}
            \hspace*{5mm}T_{test}(j) &= 1 && \text{}
        \end{flalign*}
    if there is actually a $j^{th}$ execution of the body of the loop.

    \item It now follows that the total number of steps included in this execution of the loop is at most,
        \begin{flalign*}
            \hspace*{5mm}\sum_{j=1}^{n-3} T_{body}(j) + \sum_{j=1}^{n-2} T_{test}(j) &= \sum_{j=1}^{n-3} 2 + \sum_{j=1}^{n-2} 1 &&\text{} \\
            &= 2(n-3)+(n-2) \\
            &= 2n-6+n-2 \\
            &= 3n-8 
        \end{flalign*}

    \item There is only one more statement executed after this, at line 18, and the cost of this is 1.
    
    \item Since $10 + (3n-8) + 1 = 3n+3$, it now follows that the number of steps included in an execution
    of this algorithm on a non-negative integer input $n$ is,
    \[  
        \hspace*{-91mm}T_{fmacG}(n) =
        \begin{cases} 
        2 & n = 0 \\
        3 & n = 1 \\
        4 & n = 2 \\
        5 & n = 3 \\
        3n+3 & n \geq 4 
        \end{cases}
    \]

        
\end{itemize}

% --------------------------------------------------------------
%                         13
% --------------------------------------------------------------

\begin{problem}{13} $\:$
\begin{Verbatim}[fontsize=\small]
package cpsc331.assignment1;

/**
 *
 * A class for the loop-based computation of the MacGonagall Mystery sequence
 *
 * @author Steven Ferguson (30037518)
 * @author Daniel Contreras (10080311)
 * @author Guransh Mangat (30061719)
 * @version 1.0
 *
 */

public class FMacGonagall {

    /**
     *
     * The main method for this class.
     *
     * @param args A single non-negative integer n.
     *
     */

    public static void main(String[] args) {

        if (args.length != 1) {
            System.out.println("Fiddlesticks! One integer input is required.");
            return;
        }

        try {
            int n = Integer.parseInt(args[0]);
            System.out.println(fmacG(n));
        } catch (NumberFormatException e) {
            System.out.println("Fiddlesticks! One integer input is required.");
        } catch (IllegalArgumentException e) {
            System.out.println("Fiddlesticks! The integer input cannot be negative.");
        }

    }

    /**
     *
     *  Computes the nth MacGonagall Number M_n, throwing
     *  an IllegalArgumentException if n is negative.
     *
     * Precondition:
     * An integer n given as input.
     *
     * Postcondition:
     * The nth MacGonagall Number, M_n is returned as output, and
     * an IllegalArgumentException is thrown if n < 0.
     *
     * @param n the MacGonagall Number to be computed
     * @return the nth MacGonagall Number, M_n
     * @throws IllegalArgumentException if the input is negative
     *
     */

    public static int fmacG(int n) throws IllegalArgumentException {

        // Assertion: n is an integer such that n >= 0

        if (n < 0) {
            throw new IllegalArgumentException();
        }

        switch (n) {
            case 0:
                return 1;
            case 1:
                return 0;
            case 2:
                return 5;
            case 3:
                return 8;
            default:

                int[] M = new int[n + 1];
                M[0] = 1;
                M[1] = 0;
                M[2] = 5;
                M[3] = 8;
                int i = 4;

                // Loop Invariant:
                // 1. n is an integer such that n >= 4
                // 2. i is an integer variable such that 4 <= i <= n
                // 3. M is an integer array with length n + 1
                // 4. M_j = fmacG_j for every integer j such that 0 <= j <= i
                //
                // Bound Function: n - (i - 1)

                while (i <= n) {
                    M[i] = 2 * M[i - 1] - 2 * M[i - 3] + M[i - 4];
                    i += 1;
                }

                return M[n];
        }

    }
}
\end{Verbatim}
\end{problem}


% --------------------------------------------------------------
%                         14
% --------------------------------------------------------------
    
\begin{problem}{14}
    Suppose that $M$ is a function of the non-negative integers such that,
    for every integer $n \geq 0$, \\

    \[  
        \hspace*{-91mm}M(n) =
        \begin{cases} 
        1 & i = 0 \\
        0 & i = 1 \\
        5 & i = 2 \\
        8 & i = 3 \\
        2M_{i-1} - 2M_{i-3} + M_{i-4} & i \geq 4 
        \end{cases}
    \] \\

    \noindent Then, the closed form formula is $M(n) = n^2 + (-1)^n$. 
\end{problem}

\begin{proof}
    This will be established by induction on $n$. The strong form of mathematical
    induction will be used and the cases $n=0$, $n=1$, $n=2$, and $n=3$ will be considered in
    the basis. \\

    \noindent \textit{Basis}. If $n=0$, then $M(n) = M(0) = 1$, and
    \begin{flalign*}
        \hspace*{5mm}M(n) &= n^2 + (-1)^n &&\text{}\\
        M(0) &= 0^2 + (-1)^0 \\
        &= 1 
    \end{flalign*}

    \noindent If $n=1$, then $M(n) = M(1) = 0$, and
    \begin{flalign*}
        \hspace*{5mm}M(n) &= n^2 + (-1)^n &&\text{}\\
        M(1) &= 1^2 + (-1)^1 \\
        &= 0 
    \end{flalign*}
    
    \noindent If $n=2$, then $M(n) = M(2) = 5$, and
    \begin{flalign*}
        \hspace*{5mm}M(n) &= n^2 + (-1)^n &&\text{}\\
        M(2) &= 2^2 + (-1)^2 \\
        &= 5 
    \end{flalign*}

    \noindent If $n=3$, then $M(n) = M(3) = 8$, and
    \begin{flalign*}
        \hspace*{5mm}M(n) &= n^2 + (-1)^n &&\text{}\\
        M(3) &= 3^2 + (-1)^3 \\
        &= 8 
    \end{flalign*}

    \noindent \textit{Inductive Step}. Let $k \geq 4$ be an integer. It is necessary and sufficient
    to use the following \\

    \underline{Inductive Hypothesis}: $M_{i} = i^2 + (-1)^i$
    for every integer $i$ such that $0 \leq i \leq k$. \\

    \noindent to prove the following \\

    \underline{Inductive Claim}: $M_{k+1} = \left(k+1\right)^2 + (-1)^{k+1}$ \\

    \noindent Now, 
    \begin{flalign*}
        \hspace*{5mm}M_{k+1} &= 2M_k - 2M_{k-2} + M_{k-3} &&\text{}\\
        &= 2(k^2+(-1)^k) - 2((k-2)^2+(-1)^{K-2}) + (k-3)^2 + (-1)^{k-3} &&\text{(from IH)} \\
        &= 2k^2 + 2(-1)^k - 2(k-2)^2 - 2(-1)^{k-2} + (k-3)^2 + (-1)^{k-3} \\
        &= \left(k^2 + 2k + 1\right) + (-1)^k[2-2(-1)^{-2} + (-1)^{-3}] \\
        &= (k+1)^2 + (-1)^{k+1}
    \end{flalign*}

    \noindent thus establishing the inductive claim, as required. Thefore, by principle of
    induction, $M(n) = n^2 + (-1)^n$ for all non-negative integers $n$.

\end{proof}
 
% --------------------------------------------------------------
%     You don't have to mess with anything below this line.
% --------------------------------------------------------------
 
\end{document}
