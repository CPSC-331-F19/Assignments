\documentclass[12pt]{article}
 
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb,scrextend}
\usepackage{fancyhdr}
\usepackage{enumitem}
\pagestyle{fancy}
 
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\lbr}{\lbrace}
\newcommand{\rbr}{\rbrace}
\renewcommand{\qed}{\hfill$\blacksquare$}
\let\newproof\proof
% \renewenvironment{proof}{\begin{addmargin}[1em]{0em}\begin{newproof}}{\end{newproof}\end{addmargin}\qed}
 
\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{reflection}[2][Reflection]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{proposition}[2][Proposition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
 
\begin{document}
 
% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------

\title{Assignment 1 \\ CPSC 331} % Title and subtitle
\author{Guransh Mangat, 30061719 \\ Daniel Contreras, 10080311 \\ Steven Ferguson, 30037518\\}
\date{}


\lhead{CPSC 331}
\chead{Assignment 1}
\rhead{September 2019}
 
\maketitle{}

\newpage

% --------------------------------------------------------------
%                         1
% --------------------------------------------------------------

\begin{problem}{1}
    Suppose that the function $f(n)=n$ is a bound function.
\end{problem}

\begin{proof}
    Since $n$ is an integer input, this is an \textit{integer-valued} function.\\ \\ When the 
    recursive function is applied in \textit{line 9}, the value of n is reduced by at least 1 
    ($(n-1), (n-3) \ and \ (n-4)$). \newline \newline $n$ is a non negative integer, which means 
    $n \geq 0$. Thus it is only possible that $ f(n) = n \leq 0$ when n = 0. In that case, the test 
    at \textit{line 1} passes, the execution continues at \textit{line 1} and the execution ends 
    without having to call the recursive function repeatedly. \newline \newline Hence, the function 
    $f(n) = n$ is a bound function. 
\end{proof}

% --------------------------------------------------------------
%                         2
% --------------------------------------------------------------

\begin{problem}{2}
    Prove that the smacG algorithm correctly solves the "MacGonagall Mystery Computation" problem.
\end{problem}

\begin{proof}
    \noindent This theorem will be proved by induction on $n$. The strong form of mathematical induction will be used, and base cases of $n = 0, 1, 2 ,3$ will each be considered in the basis.\\
    
    \noindent Basis: Suppose, first $n = 0$: \newline During the execution of algorithm smacG on input $n$, the test at line 1 succeeds and the execution continues at line 2. This causes the execution to terminate with the value of $M_0 = 1$ returned at output - as required for this case \\ 
    
    \noindent Suppose, next, $n = 1$: \\ During the execution of the algorithm smacG, the test at line 1 fails and the execution continues with test at line 3. \\ This test succeeds, so the execution continues at line 4. This causes the execution of algorithm to terminate with value of $M_1 = 0$ returned as output- as required by this case \\ 
    
    \noindent Suppose, $n = 2$: \\ During the execution of the algorithm smacG, the test at line 1 and line 3 fails, and the execution continues with test at line 5. \\ This test succeeds, so the execution continues with line 6. This causes the execution of the algorithm to terminate with the value of $M_2 = 5$ returned as output - as require by this case. \\ 
    
    \noindent Suppose, n = 3: \\ During the execution of the algorithm smacG, the test at line 1, line 3 and line 5 fails, and the execution continues with the test at line 7. \\ This test succeeds, so the execution continues with line 8. This causes the execution of the algorithm to terminate with the value of $M_3 = 8$ returned as output - as required by this case. \\ 
    
    \noindent \textit{Inductive Step: } Let $k$ be an integer such that $k \geq 3$. \\
    
    \noindent \textbf{Inductive Hypothesis: } Suppose $n$ is a non-negative integer such that $ 0 \leq n \leq k$. If the algorithm smacG is executed given n as input then this execution of the algorithm eventually terminates, with the $n^{th}$ MacGonagall number, $M_n$ returned as output. \\
    
    \noindent \textbf{Inductive Claim: } If the algorithm smacG is executed given $n = k + 1$ as input then this execution of the algorithm eventually terminates, with the $k+1^{st}$ MacGonagall number $M_{k+1} = M_n$ returned as output. \\
    
    \noindent Suppose the algorithm smacG is executed with $n= k + 1$ given as input. Since $k$ is an integer such that $k \geq 3$, $n$ is an integer such that $n \geq 4$.
    
    \noindent Since $n \geq 4$, the test at line 1, line 3, line 5 and line 7 fails and the algorithm continues at line 8. 
    
    \noindent Line 9 includes a recursive execution of this algorithm with the input $2 \times (n-1)$. Since $n = k + 1 \geq 4, 0 \leq n-1 = k \leq k$, and it follows by the \textbf{inductive hypothesis} that this recursive execution of the algorithm eventually ends with $M_{n-1} = M_k$ returned as output
    
    \noindent Line 9 also includes a recursive execution of this algorithm with the input $-2 \times (n-3)$. Since $n = k+1 \geq 4, 0 \leq n-3 = k-2 \leq k$, and it follows the \textbf{inductive hypothesis} that this recursive execution of the algorithm eventually ends with $M_{n-3} = M_{k-2}$ returned as output.
    
    \noindent Line 9 also includes a recursive execution of algorithm with the input $n-4$. Since $n = k+1 \geq 4, 0 \leq n-4 = k-3 \leq 4$, and it follows by the \textbf{inductive hypothesis} that this recursive function of the algorithm eventually ends with $M_{n-4} = M_{k-3}$ returned as output.
    
    \noindent Once the execution of algorithm ends, since, $k+1 \geq 4$, it follows the definition of $M_{k+1}$, that the value returned as output is: \\ \\
    $2 \times M_{n-1} - 2 \times M_{n-3} + M_{n-4} = 2 \times M_{k} -2 \times M_{k-2} + M_{k-3} = M_{k+1}$ \\ 
    
    \noindent as required to establish the \textbf{inductive claim.} \\ \\
    This results now follows by induction on n.
\end{proof}


% --------------------------------------------------------------
%                         3
% --------------------------------------------------------------

\begin{problem}{3}
\end{problem}

\begin{proof}
\end{proof}


% --------------------------------------------------------------
%                         4
% --------------------------------------------------------------

\begin{problem}{4}
\end{problem}

\begin{proof}
    In order to determine the number of steps included in the execution of $T_{smacG}(n)$, we will define the running time of each step in the algorithm to be \textit{one}.\\

    \noindent Using the uniform cost criterion to define $T_{smacG}(n)$: \\
    
    \noindent The algorithm executes 2 steps (at lines 1 and 2) if it is executed when $n = 0$. \\
    \noindent The algorithm executes 3 steps (at lines 1, 3, 4) if it is executed when $n = 1$. \\
    \noindent The algorithm executes 4 steps (at lines 1, 3, 5, 6) if it is executed when $n = 2$. \\
    \noindent The algorithm executes 5 steps (at lines 1, 3, 5, 7, 8) if it is executed when $n = 3$. \\
    
    
    \[ \hspace*{-17mm}T_{smacG}(n) = 
        \begin{cases} 
          2 & if n = 0, \\
          3 & if n = 1, \\
          4 & if n = 2, \\
          5 & if n = 3, \\
          T_{smacG}(n-1) + T_{smacG}(n-3) + T_{smacG}(n-4) + 5 & if n \geq 4.
       \end{cases}
    \]
    
    \noindent We can use this recurrence to show the following:\\
    
    \begin{flalign*}
        \hspace*{5mm}T_{smacG}(0) &= 2 &&\text{(by definition of $T_{smacG}(n)$)} \\ \\
        \hspace*{5mm}T_{smacG}(1) &= 3 &&\text{(by definition of $T_{smacG}(n)$)} \\ \\
        \hspace*{5mm}T_{smacG}(2) &= 4 &&\text{(by definition of $T_{smacG}(n)$)} \\ \\
        \hspace*{5mm}T_{smacG}(3) &= 5 &&\text{(by definition of $T_{smacG}(n)$)} \\ \\
        \hspace*{5mm}T_{smacG}(4) &= T_{smacG}(4-1) + T_{smacG}(4-3) + T_{smacG}(4-4) + 5  &&\text{} \\
        &= T_{smacG}(3) + T_{smacG}(1) + T_{smacG}(0) + 5  &&\text{} \\
        &= 5 + 3 + 2 + 5  &&\text{} \\
        &= 15. \\ \\
        \hspace*{5mm}T_{smacG}(5) &= T_{smacG}(5-1) + T_{smacG}(5-3) + T_{smacG}(5-4) + 5 &&\text{} \\
        &= T_{smacG}(4) + T_{smacG}(2) + T_{smacG}(1) + 5 &&\text{} \\
        &= 15 + 4 + 3 + 5 &&\text{} \\
        &= 27.
    \end{flalign*}

\end{proof}


% --------------------------------------------------------------
%                         5
% --------------------------------------------------------------

\begin{problem}{5} 
    Suppose that $T_{smacG}$ is a function of the non-negative integers such that, for every integer 
    $n \geq 0$,

    \[  
        \hspace*{-22mm}T_{smacG}(n) =
        \begin{cases} 
        2 & n = 0 \\
        3 & n = 1 \\
        4 & n = 2 \\
        5 & n = 3 \\
        T_{smacG}(n-1) + T_{smacG}(n-3) + T_{smacG}(n-4) + 5 & n \geq 4 
        \end{cases}
    \]

    \noindent then $T_{smacG}(n) \geq \left(\frac{3}{2}\right)^n$ for every non-negative integer $n$ and therefore
    the number of steps executed by the $smacG$ algorithm is at least exponential in its input.
\end{problem}

\begin{proof} 
This will be established by induction on $n$. The strong form of mathematical induction will be used 
and the cases $n = 0$, $n=1$, $n=2$ and $n=3$ will be considered in the basis.\\

\noindent \textit{Basis}. If $n=0$, then $T_{smacG}\left(n\right) = T_{smacG}\left(0\right) = 2$, and 
\begin{flalign*}
    \hspace*{5mm}T_{smacG}(n) &\geq \left(\frac{3}{2}\right)^n &&\text{} \\
    T_{smacG}\left(0\right) &\geq \left(\frac{3}{2}\right)^0 &&\text{} \\
    2 &\geq 1 &&\text{} \\
\end{flalign*}
as required. If $n=1$, then $T_{smacG}\left(n\right) = T_{smacG}\left(1\right) = 3$, and 
\begin{flalign*}
    \hspace*{5mm}T_{smacG}\left(n\right) &\geq \left(\frac{3}{2}\right)^n &&\text{} \\
    T_{smacG}\left(1\right) &\geq \left(\frac{3}{2}\right)^1 &&\text{} \\
    3 &\geq \frac{3}{2} &&\text{} \\
\end{flalign*}
as required. If $n=2$, then $T_{smacG}\left(n\right) = T_{smacG}\left(2\right) = 4$, and 
\begin{flalign*}
    \hspace*{5mm}T_{smacG}\left(n\right) &\geq \left(\frac{3}{2}\right)^n &&\text{} \\
    T_{smacG}\left(2\right) &\geq \left(\frac{3}{2}\right)^2 &&\text{} \\
    4 &\geq \frac{9}{4} &&\text{} \\
\end{flalign*}
as required. If $n=3$, then $T_{smacG}\left(n\right) = T_{smacG}\left(3\right) = 5$, and 
\begin{flalign*}
    \hspace*{5mm}T_{smacG}\left(n\right) &\geq \left(\frac{3}{2}\right)^n &&\text{} \\
    T_{smacG}\left(3\right) &\geq \left(\frac{3}{2}\right)^3 &&\text{} \\
    5 &\geq \frac{27}{8} &&\text{} \\
\end{flalign*}
as required. \\

\noindent \textit{Inductive Step}. Let $k \geq 4$ be an integer. It is necessary and sufficient
to use the following \\

\underline{Inductive Hypothesis}: $T_{smacG}\left(m\right) \geq \left(\frac{3}{2}\right)^{m}$
for every integer $m$ such that $0 \leq m \leq k$. \\

\noindent to prove the following \\

\underline{Inductive Claim}: $T_{smacG}\left(k+1\right) \geq \left(\frac{3}{2}\right)^{k+1}$ \\

\noindent Now, since $k+1 > 4$,

\begin{flalign*}
    \hspace*{5mm}T_{smacG}(k+1) &= T_{smacG}(k) + T_{smacG}(k-2) + T_{smacG}(k-3) + 5 \\
    &\geq \left(\frac{3}{2}\right)^{k} + \left(\frac{3}{2}\right)^{k-2} + \left(\frac{3}{2}\right)^{k-3} + 5 &&\text{(by inductive hypothesis)} \\
    &= \left(\frac{3}{2}\right)^{k+1} + \left(\left(\frac{3}{2}\right)^{-1} + \left(\frac{3}{2}\right)^{-3} + \left(\frac{3}{2}\right)^{-4}\right) + 5 \\
    &= \left(\frac{3}{2}\right)^{k+1} \left(\frac{94}{81}\right) + 5 \\
    &\geq \left(\frac{3}{2}\right)^{k+1} \left(\frac{94}{81}\right) \\
    &\geq \left(\frac{3}{2}\right)^{k+1} &&\text{(because $\frac{94}{81} > 1$)}\\
\end{flalign*}

\noindent thus establishing the inductive claim, as needed. Therefore, by principle of induction 
$T_{smacG}\left(n\right) \geq \left(\frac{3}{2}\right)^{n}$ for all non-negative integers $n$.

\end{proof} 

% --------------------------------------------------------------
%                         6
% --------------------------------------------------------------

\begin{problem}{6}
State a loop invariant for the while loop at lines $15 \-- 17$
of this algorithm
\end{problem}

\begin{proof}
\begin{enumerate}
        \item \textit{n} is an integer input such that $n \geq 4$
        \item \textit{i} is an integer variable such that $4 \leq i \leq n$
        \item \textit{M} is an integer array with length $n+1$
        \item $M_{j} = fmacG_{j}$ for every integer j such that $ 0 \leq j \leq i$
   \end{enumerate}
\end{proof}


% --------------------------------------------------------------
%                         7
% --------------------------------------------------------------

\begin{problem}{7}
Prove that your answer for the previous question really is a loop invariant for the while
loop in this algorithm.
\end{problem}

\begin{proof}
We will use Loop Theorem 1 to prove this loop invariant.
\begin{enumerate}
    \item The loop test at \textit{line 15} has no side effects. 
    \item Consider the execution of the algorithm with the precondition for the ``MacGonagall Mystery Computation" satisfied. There is nothing to be proved if the while loop at \textit{line 15} is never reached, so if tests at \textit{line 1, 3, 5, 7} fail, then \textit{lines 9-15} are executed. By the inspection of code, we can say that the loop is not executed more than once. So it suffices us to consider the first execution of the loop. 
    \\
    The precondition for the ``MacGonagall Mystery Computation" states that $n$ needs to be a non-negative integer i.e. $n \geq 0$ when the execution of the algorithm begins and by inspection, the value of $n$ never changes. Furthermore, $n \neq 1,2,3$ as tests at \textit{line 1, 3, 5 and 7} pass and the loop is never reached. Thus, $n \geq 4$ which establishes part 1 of the loop invariant when the execution of loop begins. One can see by the inspection of the code, $i$ is an integer variable with a value of $4$ when the execution of the loop begins, since $n \geq 4$, this establishes part 2 of the loop invariant when the execution of the loop begins. Since $M$ is an \textit{integer-array} variable whose length is set to be $n+1$. Finally, since \emph{lines 10, 11, 12, and 13} have been executed (and M is not changed at step 14), $M[0] = fmacG_{0}, M[1] = fmacG_{1}, M[2] = fmacG_{2}, and M[3] = fmacG_{3}$. Since $i=4, M[j] = fmacG_{j}$ for every integer $j$ such that $0 \leq i \leq j$. Thus, the fourth part of the assertion before the execution of the loop body, as required for the proof of the claim.
    
    \item Consider an execution of the body of this loop that begins with the proposed "loop invariant" satisfied. It follows by \emph{part 1} of the loop invariant that $n$ is initially and integer variable such that $n \geq 4$ and since, the value of $n$ is not changed during the executions of \emph{line 16, 17}, this is also true when the execution of this loop ends. It follows by \emph{part 2} of the loop invariant that $i$ is an integer variable such that $4 \leq i \leq n$. Since, the test at \emph{line 15} was checked and passed, $i < n$ so that $4 \leq i \leq n-1$ at this point.
    When the value of n is never changed, the value of $i$ is increased by one during the execution of \emph{line 17}, so $5 \leq i \leq n$ at the end of the execution of this loop body and \emph{part 2} of the loop invariant is satisfied at the end of this execution of the loop body as well.
    
   \end{enumerate}
\end{proof}


% --------------------------------------------------------------
%                         8
% --------------------------------------------------------------

\begin{problem}{8}

\noindent
By inspection of the function signature for $fmacG(n)$, this algorithm has no undocumented side effects - that is it does not access or change inputs or global data, and does not create outputs unless documented in the “MacGongall Mystery Computation” problem. \\

\noindent
It now suffices to show that if the $fmacG(n)$ is executed when the precondition for the “MacGongall Mystery Computation” is satisfied, then either:
\begin{enumerate}[label=(\alph*)]
\item The execution of the algorithm halts, with the postcondition for the “MacGongall Mystery Computation” problem being satisfied when this occurs, or alternatively
\item The algorithm runs forever, whereby the algorithm never halts at all
\end{enumerate}

\noindent
Now, consider an execution of this algorithm where the precondition of this problem is initially satisfied. That is, such that $n$ is an integer input where $n \geq 0$.

\begin{itemize}

\item Suppose that $n = 0$. In this case, the test at line 1 passes, and the execution of the algorithm halts after reaching line 2, where $M_0 = M_n = 1$ is returned, as required to satisfy our condition established in $(a)$.

\item Suppose that $n = 1$. In this case, the test at line 1 fails, and the execution of the algorithm proceeds and passes the test at line 3, where the execution of the algorithm halts after the execution of line 4, and $M_1 = M_n = 0$ is returned, as required to satisfy our condition established in $(a)$.

\item Suppose that $n = 2$. In this case, the test at line 1 and 3 fail, and the execution of the algorithm proceeds and passes the test at line 5, where the execution of the algorithm halts after the execution of line 6, and $M_2 = M_n = 5$ is returned, as required to satisfy our condition established in $(a)$.

\item Suppose that $n = 3$. In this case, the test at line 1, 3, and 5 fail, and the execution of the algorithm proceeds and passes the test at line 7, where the execution of the algorithm halts after the execution of line 8, and $M_3 = M_n = 8$ is returned, as required to satisfy our condition established in $(a)$.

\item The only other case is when $n \geq 4$, such that the tests at lines 1, 3, 5, and 7 fail, and the steps at $9 \rightarrow 14$ are executed, which proceeds to the while loop that is later executed. Should the while loop run indefinitely, then the execution of the algorithm never halts, and the condition established in $(b)$ is satisfied. \\

If the algorithm does not halt during loop body execution, then the loop invariant is satisfied at this point of execution, such that $n$ is an input integer where $n \geq 4$, and $i$ is an integer variable such that $4 \leq i \leq n$ as established in $(1)$ and $(3)$ of the loop invariant. Since the algorithm halts, then the test at line 15 has been evaluated and thus failed, this means $i \leq n$ as well, that is $i = n$ after the execution of the loop body.

\end{itemize}

\noindent
It can now be said for part 4 of the loop invariant that $M[j] = fmacG_j = M_n$, such that the nth MacGonagal has been returned as output following the return statement at line 18 being executed, whereby condition $(a)$ has been satisfied.

\end{problem}

% --------------------------------------------------------------
%                         9
% --------------------------------------------------------------

\begin{problem}{9}
    The function $f\left(n,i\right) = n - (i - 1)$ is a bound function for the while
    loop in this algorithm. 
\end{problem}

\begin{proof} Consider the above function $f$. \\

    \noindent Since $n$ is an integer input and $i$ is an integer variable, defined and 
    initialized at step 14, this is certainly an integer-valued total function of
    some of the inputs, variables and global data in the $fmacG$ algorithm. \\

    \noindent When the body of the while loop is executed, the value of $i$ is increased
    by one (at step 17) and the value of $n$ is not changed. Hence, the value of $f$ is
    decreased by at least one. \\

    \noindent If the value of $f$ is less than zero then $n-(i-1) < 0$, so that $i > n$ and the loop
    test (at line 15) fails, causing the execution of the loop to halt. \\

    \noindent It then follows by definition of a bound function for a while loop that $f$ is a bound 
    function for the while loop in the $fmacG$ algorithm, as claimed.
\end{proof}


% --------------------------------------------------------------
%                         10
% --------------------------------------------------------------

\begin{problem}{10}

Consider the $fmacG(n)$ function being executed such that the precondition for the “MacGonagall Mystery Computation” problem is satisfied. The precondition of this problem assumes that is a non-negative integer before execution of the algorithm begins, that is $n \geq 0$. \\

\noindent
If n = 0, then the test at line 1 passes, and the execution of the algorithm halts after reaching line 2. \\

\noindent
If n = 1, then the test at line 1 fails, and the execution of the algorithm proceeds and passes the test at line 3, where the execution of the algorithm halts after the line 4. \\

\noindent
If n = 2, then the test at line 1 and 3 fail, and the execution of the algorithm proceeds and passes the test at line 5, where the execution of the algorithm halts after the execution of line 6. \\

\noindent
If n = 3, then the test at line 1, 3, and 5 fail, and the execution of the algorithm proceeds and passes the test at line 7, where the execution of the algorithm halts after the execution of line 8. \\

\noindent
Otherwise, if $n \geq 4$, the test at lines 1, 3, 5, and 7 fail, and the steps at lines $9 \rightarrow 14$ execute, and the execution of the loop body begins.

\begin{itemize}
    \item The loop test at line 15 simply compares the integer input $n$ and a counter variable $i$, thus it has no side effects, and each execution of this loop body eventually halts.
    \item The body of this while loop is simply two assignment statements, thus every execution of the loop body halts as well.
    \item As noted in question (9), this while loop has a bound function.
\end{itemize}

\noindent
It can now be proved by ``Loop Theorem #2'' that the execution of the while loop terminates. The execution of this algorithm terminates after the execution of the return statement at line 18, which establishes the claim. It now follows in question $(11)$ that this algorithm is correct.


\end{problem}


% --------------------------------------------------------------
%                         11
% --------------------------------------------------------------

\begin{problem}{11}
\end{problem}

\begin{proof}
\end{proof}


% --------------------------------------------------------------
%                         12
% --------------------------------------------------------------

\begin{problem}{12}
\end{problem}

\begin{proof}
\end{proof}


% --------------------------------------------------------------
%                         13
% --------------------------------------------------------------

\begin{problem}{13}
\end{problem}

\begin{proof}
\end{proof}


% --------------------------------------------------------------
%                         14
% --------------------------------------------------------------
    
\begin{problem}{14}
\end{problem}

\begin{proof}
\end{proof}

 
% --------------------------------------------------------------
%     You don't have to mess with anything below this line.
% --------------------------------------------------------------
 
\end{document}
