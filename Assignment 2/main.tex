\documentclass[12pt]{article}
 
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb,scrextend}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{fancyvrb}
\pagestyle{fancy}
 
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\lbr}{\lbrace}
\newcommand{\rbr}{\rbrace}
\renewcommand{\qed}{\hfill$\blacksquare$}
\let\newproof\proof
% \renewenvironment{proof}{\begin{addmargin}[1em]{0em}\begin{newproof}}{\end{new``proof}\end{addmargin}\qed}
 
\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{reflection}[2][Reflection]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{proposition}[2][Proposition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
 
\begin{document}
 
% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------

\title{Assignment 2 \\ CPSC 331} % Title and subtitle
\author{Guransh Mangat, 30061719 \\ Daniel Contreras, 10080311 \\ Steven Ferguson, 30037518\\}
\date{}


\lhead{CPSC 331}
\chead{Assignment 2}
\rhead{October 2019}
 
\maketitle{}

\newpage

% --------------------------------------------------------------
%                         1
% --------------------------------------------------------------
\begin{problem}{1}
Describe how an algorithm for the ``Treap Restoration after Insertion" problem could be
used, along with an algorithm for insertion into a binary search tree, to obtain an algorithm for the ``Insertion into This Treap" problem. Briefly explain why the algorithm you
have described would be correct
\end{problem}

\begin{proof}
The ``insertion into a binary search tree'' can be used along with ``Insertion into Subtree" algorithm. Whenever ``insertion into subtree"" algorithm is called with the preconditions satisfied, a node is included into the subtree with root \emph{x}- either by replacing the value at the node storing $k$, or by adding a new node if no such node existed.The ``insertion into the subtree" algorithm ensures that each element stored in a node in the left subtree of the subtree with root x is \emph{less than} the element stored at x, and each element stored in a node in the
right subtree of the subtree with root x is \emph{greater than} the element stored at x. 
\\ \\
Once ``insertion into binary search tree" algorithm is executed, the elements \emph{E} int the Treap $T$ are stored satisfying property $(b)$ of the definition of Treaps.
\\ \\
We then continue with executing ``Treap Restoration after Insertion" algorithm with the preconditions satisfied.This ensured that he priority associated with each element of $E$, that is stored in Treap $T$, has not been changed. That is, if an element $e \in E$ and priority $p \in P$ were stored in the same node of $T$ before this computation began, then $e$ and $p$ are also both stored in the same node of T after the computation ends.
\\ \\
Once ``Treap Restoration after Insertion" algorithm is executed, the priorities $P$ are stored in the Treap $T$ satisfying property $(c)$ of the definition of the Treaps.
\end{proof}



%------------------------------------------------------------------------
%                         Problem 2
%------------------------------------------------------------------------
\begin{problem}{2}

\end{problem}

\begin{proof}

\end{proof}



%------------------------------------------------------------------------
%                         Problem 3
%------------------------------------------------------------------------
\begin{problem}{3}
$\newline$
\begin{verbatim}
    private void restoreAfterInsertion(TreapNode x) {
        if (x.priority.compareTo(x.parent.priority()) == 1) {
            if (x.parent.left() != null) {
                if (x.parent.left().equals(x)) {
                    rightRotate(x.parent);
                } else {
                    leftRotate(x.parent);
                }
            } else if (x.parent.right() != null) {
                if (x.parent.right().equals(x)) {
                    leftRotate(x.parent);
                } else {
                    rightRotate(x.parent);
                }
            }
        }
        if (x.parent() != null && x.priority.compareTo(x.parent.priority()) == 1) {
            restoreAfterInsertion(x);
        }
    }
\end{verbatim}
\end{problem}

\begin{proof}

\end{proof}



%------------------------------------------------------------------------
%                         Problem 4
%------------------------------------------------------------------------
\begin{problem}{4}

\end{problem}

\begin{proof}

\end{proof}


%------------------------------------------------------------------------
%                         Problem 5
%------------------------------------------------------------------------
\begin{problem}{5}

\end{problem}

\begin{proof}

\end{proof}


%------------------------------------------------------------------------
%                         Problem 6
%------------------------------------------------------------------------
\begin{problem}{6}

Suppose the \texttt{delete} method is executed with the with the precondition for the Treap Deletion initially satisfied, so that \texttt{T} satisfies
the Treap properties and \texttt{x} is the node storing a non-null input key of type \texttt{E} that is found successfully within the Treap. Since \texttt{x} is non-null,
then \texttt{T} must have at least one node such that the root is non-null as well, and additionally, since we are assuming that key is indeed found, and
\texttt{x} is the value that stores the input key, then \texttt{x} exists, and a NoSuchElementException would not be thrown in this case. The deleteFromSubtree method
is then called, where the node to be deleted is returned, which we will call \texttt{z}. Finally, execution is returned to the \texttt{delete} method, whereby
\texttt{restoreAfterDeletion} is performed on the node \texttt{z} that was returned from the delete operation. We have three cases: \newline

\noindent
\textbf{Case 1: left and right node at z are both null:} \newline
If \texttt{z} has no children, and the parent of \texttt{z} is null, then \texttt{z} is the root node, in which case the root would be set to null. In this case, \texttt{T} is now an empty tree, 
and satisfies the Treap definition. If \texttt{z} is has a non-null parent and the value of \texttt{z} is less than the value of its parent, then the left node at \texttt{z}'s parent is set
to null. Otherwise, if the value of \texttt{z} is greater than the value of its parent, then the right node at \texttt{z}'s parent is set to null. Since \texttt{z} was a leaf node, and
each node in \texttt{T} is still an ordered pair $(e, p)$ where $e \in E$ and $p \in P$, and the value of \texttt{z} was less than its parent, then \texttt{T} satisfies both $(a)$ and $(b)$ of the Treap
definition. Finally, Since the priority of each node in the tree has not been modified, $(c)$ is satisfied as well. \newline

\noindent
\textbf{Case 2: Left child at z is null but right child is not} \newline
In this case, \texttt{z} has a null left node but a non-null right node. If \texttt{z}’s parent is null, then \texttt{z} is the root, the parent node of \texttt{z}’s rightmost child is set to null,
and the root is updated to \texttt{z}’s rightmost child. Since \texttt{z} was the root, and its children satisfy property $(b)$ of the Treap definition, then $(b)$ is indeed satisfied
after its rightmost child has been updated to the root. If \texttt{z} does have a parent, and the value at \texttt{z} is less than its parent, then the left node at \texttt{z}’s parent is set
to the right node at \texttt{z}, otherwise the right node at \texttt{z}’s parent is set to the right node at \texttt{z}. Finally, the parent of \texttt{z}’s right node is set to \texttt{z}’s own parent. Since
each node in \texttt{T} is still an ordered pair $(e, p)$ where $e \in E$ and $p \in P$, and the value of \texttt{z} was less than its parent, then \texttt{T} satisfies both $(a)$ and $(b)$ of the Treap definition.
Finally, Since the priority of each node in the tree has not been modified, $(c)$ is satisfied as well. \newline

\noindent
\textbf{Case 3: Left child at z is not null but right child is} \newline
In this case, \texttt{z} does not have a left child but has a right child. If the parent of \texttt{z} is null , then \texttt{z} is the root node, and the parent of \texttt{z}’s leftmost child is set
to null, whereby the root of the tree is updated to \texttt{z}’s leftmost child. Since \texttt{z} was the root, and its children satisfy property $(b)$ of the Treap definition, then $(b)$
is indeed satisfied after its leftmost child has been updated to the root. If the parent at \texttt{z} is not null, and the value at \texttt{z} is less than its parent, then the left
node at \texttt{z}’s parent is set to the current left child of \texttt{z}, otherwise if the value at \texttt{z} is greater than its parent, then the right node at \texttt{z}’s parent is set to the
current left child of \texttt{z}. Finally, the parent of \texttt{z}’s left node is set to \texttt{z}’s own parent. Since each node in \texttt{T} is still an ordered pair $(e, p)$ where $e \in E$ and $p \in P$, and the
value of \texttt{z} was less than its parent, then \texttt{T} satisfies both $(a)$ and $(b)$ of the Treap definition. Finally, Since the priority of each node in the tree has not been
modified, $(c)$ is satisfied as well. \newline

\noindent
Since we are only evaluating if the node \texttt{x} being deleted has at most 1 child in the Treap, then we do not need to consider the case if \texttt{x} has both a non-null left and
right child, as no rotation is required in this case.

\end{problem}



%------------------------------------------------------------------------
%                         Problem 7
%------------------------------------------------------------------------
\begin{problem}{7}

Suppose the precondition for the ``Treap Restoration after Deletion'' problem is satisfied, and a right rotation is performed at \texttt{x} such that \texttt{x}
has a non-null left child, and the priority of the left child at \texttt{x} is greater than or equal to the priority at the right child of \texttt{x}, if it
exists. When \texttt{rightRotate} is called where \texttt{x} is passed as input, the leftmost child of \texttt{x} will be updated to the rightmost child of the leftmost
child of \texttt{x}. If the rightmost child of \texttt{x}’s leftmost child is not null, then the parent of this node will be set to \texttt{x}. Finally, the parent of
\texttt{x}’s leftmost child will be set to \texttt{x}’s current parent. If \texttt{x} does not have a parent, then the root of the tree will become \texttt{x}’s leftmost child.
Otherwise, if \texttt{x} is the same node stored at the rightmost child of \texttt{x}’s parent, then the rightmost child of \texttt{x} is set to the leftmost child of \texttt{x}.
If they are not the same node, then the leftmost child at \texttt{x}’s parent is set to the leftmost child at \texttt{x}. Finally, the rightmost child of \texttt{x}’s
leftmost child is set to \texttt{x}, and the parent of \texttt{x} is set to the original leftmost child of \texttt{x}.

\end{problem}


%------------------------------------------------------------------------
%                         Problem 8
%------------------------------------------------------------------------
\begin{problem}{8}

\begin{verbatim}

    private void restoreAfterDeletion(TreapNode x) {
        if (x.left == null) {
            if (x.right == null) {
                // case 1: leaf node or root
                if (x.parent == null) {
                    root = null;
                } else {
                    TreapNode parent = x.parent;
                    if (x.element.compareTo(parent.element) == -1) {
                        parent.left = null;
                    } else {
                        parent.right = null;
                    }
                }
            } else {
                // case 2: left child is null but right child is not
                TreapNode rightChild = x.right;
                if (x.parent == null) {
                    rightChild.parent = null;
                    root = rightChild;
                } else {
                    TreapNode parent = x.parent;
                    if (x.element.compareTo(parent.element) == -1) {
                        parent.left = rightChild;
                    } else {
                        parent.right = rightChild;
                    }
                    rightChild.parent = parent;
                }
            }
        } else if (x.right == null) {
            // case 3: left child is not null but right child is
            TreapNode leftChild = x.left;
            if (x.parent == null) {
                leftChild.parent = null;
                root = leftChild;
            } else {
                TreapNode parent = x.parent;
                if (x.element.compareTo(parent.element) == -1) {
                    parent.left = leftChild;
                } else {
                    parent.right = leftChild;
                }
                leftChild.parent = parent;
            }
        } else {
            // case 4: Neither the left nor the right of x is null (need to rotate)
            if (x.left.priority.compareTo(x.right.priority) == 1) {
                rightRotate(x);
            } else {
                leftRotate(x);
            }
            restoreAfterDeletion(x);
        }
    }

\end{verbatim}


\end{problem}


%------------------------------------------------------------------------
%                         Problem 9
%------------------------------------------------------------------------
\begin{problem}{9}

\end{problem}

\begin{proof}

\end{proof}


%------------------------------------------------------------------------
%                         Problem 10
%------------------------------------------------------------------------
\begin{problem}{10}

\end{problem}

\begin{proof}

\end{proof}


%------------------------------------------------------------------------
%                         Problem 11
%------------------------------------------------------------------------
\begin{problem}{11}

\end{problem}

\begin{proof}

\end{proof}


\end{document}
